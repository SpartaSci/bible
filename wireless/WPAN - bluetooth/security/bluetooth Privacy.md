
[[wireless/WPAN - bluetooth/security/_bluetooth security|_bluetooth security]]




> [!question] Problem
> Bluetooth devices continuously send data in packets containing the MAC address of the sender and receiver, making it possible for an attacker to passively listen to packets and track a device person


> [!idea] solution
> In practise, using **private addresses** that are **randomly generated** and rotated frequently. Ideally every 15 minutes


> [!question] **How** can a paired device **keep being paired**?


> [!success] solution
Paired devices can maintain their pairing by using **resolvable private addresses** generated using the device **Identity Resolving Key IRK** generated during boinding

Privacy mode:
- **Device Privacy Mode**: only concerned about its **own privacy**. It should accept advertising packets from peer devices that contain their Identity Addresses as well as their private address, even if the peer device has distributed its IRK
- **Network Privacy Mode**: it shall not accept advertising packets containing Identify Address of peer devices that have not distributed their IRK. *Accept only packets from peers that use their private addresses IRK and that can be validated*

# device addresses

**public address**: global and fixed

**random address**: no need to be registered
- **static address**: randomly generated at each boot
	- ends in 11
- **private address**: generated and rotated to avoid tracking
	- **non-resolvable** 
		- ends in 00 
		- just a random sequence of 46 bits (+00).
		- Does not allow bonding.
		- Used sometimes in beacon applications 
	- **Resolvable** 
		- ends in 10 
		- Avoids tracking 
		- allow bonding 
		- Generated by the IRK. Can be resolved by trusted device only

# resolvable private address

After pairing, during [[wireless/WPAN - bluetooth/security/pairing/_pairing#bonding|bonding phase]] the devices exchange and share keys 

The **Identity Resolving Key** (IRK) allows the device to *sign* the address so that only devices that knows the IRK can resolve the address

**Address generation** 
- Generate a 22-bit random sequence $PRAND$ 
- Compute a 24-bit hash using the $IRK_a: localHash = ah(IRK, PRAND)$ 
- *Share address* = $localHash\  ||\ PRAND\ ||\ 10$ 

**Address verification/resolution** 
- Extract 22-bit $PRAND$ 
- Compute the 24-bit hash using the $IRK_a: localHash = ah(IRK, PRAND)$ 
- Compare $localHash$ and Hash. 

Note: Device must maintain a local store of IRK and identities. Updated during bonding


